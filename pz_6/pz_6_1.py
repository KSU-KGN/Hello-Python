"""
1) Из ваших заданий в уроках 1-5 найти 2-3 скрипта, сделать замеры времени,
оптимизировать, вновь выполнить замеры и ОПИСАТЬ СЛОВАМИ, что вы сделали и
чего удалось добиться
Описания нужно делать в виде docstrings
"""
from timeit import timeit
from pz_6_1_code import my_func_1
from pz_6_1_code import my_func_2
from pz_6_1_code import my_func_3
from pz_6_1_code import my_func_4
"""
Проверка скриптов блок 1
pow(user_x, user_y) - втроенная функция возведения в степень
my_func_1(user_x, user_y) - возведение в степень с помощью оператора **.
my_func_2(user_x, user_y) - более сложная реализация без оператора *,
                            предусматривающая использование цикла
"""
user_x = 11.1
user_y = -5
print("Проверка скриптов блок 1")
print(timeit("pow(user_x, user_y)", globals=globals(), number=100000))
print(timeit("my_func_1(user_x, user_y)", globals=globals(), number=100000))
print(timeit("my_func_2(user_x, user_y)", globals=globals(), number=100000))
"""
Получили результат:
0.0179056
0.024554299999999994
0.052107200000000006
pow(user_x, user_y): встроенная функция возведения в степень работает быстрее
всего, потому что она встроенная ;-)
my_func_1(user_x, user_y): если использовать возведение в степень с помощью
оператора **, то мы видим немного более медленную работу, хотя действие
оператора эквивалентно вызову встроенной функции pow()
my_func_2(user_x, user_y): более сложная реализация без оператора *,
предусматривающая использование цикла, поэтому, увеличив сложность алгоритма,
мы получили самую медленну скорость возведения в степень
Вывод: встроенные функции работают быстрее
"""
"""
Проверка скриптов блок 2
my_func_3() - формирование списка четных чисел от 100 до 1000 (включая границы)
              с помощью цикла.
my_func_4() - формирование списка четных чисел от 100 до 1000 (включая границы)
              с помощью lc
"""
print("\nПроверка скриптов блок 2")
print(timeit("my_func_3()", globals=globals(), number=1000))
print(timeit("my_func_4()", globals=globals(), number=1000))
"""
Получили результат:
0.05725620000000001
0.0451916
my_func_3(): если использовать формирование списка четных чисел от 100 до 1000
(включая границы) с помощью цикла, мы увеличиваем сложность алгоритма, поэтому
видим более медленную работу
my_func_2(): если использовать формирование списка четных чисел от 100 до 1000
(включая границы) с помощью lc, мы видим более быструю работу, т.к. используем
встроенные возможности
Вывод: встроенные возможности lc работают быстрее
"""
